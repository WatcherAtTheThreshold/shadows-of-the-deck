
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shadows in the Deck - Enhanced Mechanics</title>
<style>
  body { font-family: sans-serif; background: #111; color: #eee; text-align: center; }
  #game { max-width: 900px; margin: auto; }
  #market, #player-hand { display: flex; justify-content: center; margin: 10px 0; min-height: 155px; }
  .card { background: #333; border: 2px solid #666; border-radius: 8px; width: 100px; height: 140px; margin: 5px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; text-align: center; padding: 5px; box-sizing: border-box; }
  .card:hover { border-color: gold; }
  .cost { font-size: 0.8em; color: gold; margin-top: auto; padding-bottom: 5px; }
  #map { display: flex; justify-content: center; margin: 20px 0; }
  .node { width: 40px; height: 40px; border-radius: 50%; background: #555; margin: 5px; position: relative; }
  .player { width: 20px; height: 20px; border-radius: 50%; background: cyan; position: absolute; top: 10px; left: 10px; }
  .fragment { width: 14px; height: 14px; border-radius: 50%; background: gold; position: absolute; bottom: 3px; right: 3px; }
  .encounter { width: 14px; height: 14px; border-radius: 50%; position: absolute; top: 3px; right: 3px; }
  .encounter.treasure { background: lime; }
  .encounter.heal { background: lightblue; }
  .encounter.buff { background: orange; }
  #log { background: #222; padding: 10px; min-height: 60px; margin-top: 20px; border-radius: 6px; }
  #error-log { color: red; font-size: 0.9em; min-height: 20px; }
  #restart-btn, #end-turn-btn { margin-top: 15px; padding: 8px 16px; border: none; border-radius: 6px; background: gold; color: #111; font-weight: bold; cursor: pointer; }
  #restart-btn:hover, #end-turn-btn:hover { background: orange; }
  #hud { margin: 10px; font-weight: bold; }
</style>
</head>
<body>
<div id="game">
  <h1>Shadows in the Deck</h1>
  <div id="hud">
    Coins: <span id="coins">0</span> |
    Fragments Collected: <span id="frags">0</span> |
    Turns Left: <span id="turns-left">0</span>
  </div>
  <div id="error-log"></div>
  <h2>Market</h2>
  <div id="market"></div>
  <h2>Your Hand</h2>
  <div id="player-hand"></div>
  <button id="end-turn-btn" onclick="endTurn()">End Turn</button>
  <h2>Dream Map</h2>
  <div id="map"></div>
  <div id="log"></div>
  <button id="restart-btn" style="display:none;" onclick="restartGame()">Restart Game</button>
</div>
<script>
let marketDeck, playerDeck, discardPile, playerHand, marketRow, mapNodes, playerPos, fragmentPositions, fragmentsCollected, totalFragments, cruxflareDeck, coins, encounterPositions, isShadowBlocked, moveBuff;

function setupGameData(){
  marketDeck = [
    { name:"Focus +2", cost: 3 },
    { name:"Move +2", cost: 4 },
    { name:"Dream Compass", cost: 5, effect: 'draw' }, // Renamed and given a clear effect
    { name:"Shadow Blocker", cost: 4 },
    { name:"Card Purge", cost: 6, effect: 'purge' }, // Added to clarify effect
    { name:"Focus +3", cost: 5 },
    { name:"Move +3", cost: 6 }
  ].sort(() => Math.random() - 0.5); // Shuffle market for variety

  playerDeck = ["Focus +1","Focus +1","Focus +1","Focus +1","Focus +1","Focus +1","Move +1","Move +1","Move +1","Move +1"];
  playerDeck = playerDeck.sort(() => Math.random() - 0.5); // Shuffle starting deck

  discardPile = [];
  playerHand = [];
  marketRow = [];
  mapNodes = 6;
  playerPos = 0;
  fragmentPositions = [2, 4];
  fragmentsCollected = 0;
  totalFragments = fragmentPositions.length;
  encounterPositions = [ {pos:1,type:'treasure'}, {pos:3,type:'heal'}, {pos:5,type:'buff'} ];

  cruxflareDeck = [
    "Shadow Surge: Add a 'Shadow (dead)' card to your discard pile.",
    "Corruption Pulse: The cheapest card is removed from the market.",
    "Dream Collapse: A node is removed from the end of the map.",
    "Sudden Eclipse: A random card is discarded from your hand."
  ];
  cruxflareDeck = cruxflareDeck.sort(() => Math.random() - 0.5);

  coins = 0;
  isShadowBlocked = false;
  moveBuff = 0;
}

function initGame(){
  setupGameData();
  document.getElementById('restart-btn').style.display = 'none';
  document.getElementById('end-turn-btn').style.display = 'inline-block';

  logMsg("Use Focus to gain Coins for better cards. Use Move to collect Fragments before the dream collapses!");

  for (let i = 0; i < 5; i++) {
    if(marketDeck.length > 0) marketRow.push(marketDeck.shift());
  }
  renderMarket();
  drawHand();
  renderHand();
  renderMap();
  updateHUD();
}

function drawHand(){
  while(playerHand.length < 5){
    if(playerDeck.length === 0){
      if(discardPile.length === 0) break; // No cards left anywhere
      playerDeck = discardPile.sort(() => Math.random() - 0.5);
      discardPile = [];
    }
    playerHand.push(playerDeck.shift());
  }
}

function renderMarket(){
  let m = document.getElementById('market');
  m.innerHTML = '';
  marketRow.forEach((cardObj, i) => {
    let el = document.createElement('div');
    el.className = 'card';
    el.innerHTML = `<div>${cardObj.name}</div><div class='cost'>Cost: ${cardObj.cost}</div>`;
    el.onclick = () => {
      if(coins >= cardObj.cost){
        coins -= cardObj.cost;
        logMsg(`Bought ${cardObj.name}.`);
        // Bought cards go to the discard pile
        discardPile.push(cardObj);
        marketRow.splice(i,1);
        if(marketDeck.length > 0) marketRow.push(marketDeck.shift());
        renderMarket();
        updateHUD();
      } else {
        errorMsg(`Not enough coins to buy ${cardObj.name}.`);
      }
    };
    m.appendChild(el);
  });
}

function renderHand(){
  let h = document.getElementById('player-hand');
  h.innerHTML = '';
  playerHand.forEach((card, i) => {
    // Card can be a string (from starting deck) or an object (from market)
    const cardName = typeof card === 'string' ? card : card.name;
    let el = document.createElement('div');
    el.className = 'card';
    el.textContent = cardName;
    el.onclick = () => {
      let cardToDiscard = playerHand.splice(i, 1)[0];

      if(cardName.includes('Move')){
        let moveValue = parseInt(cardName.replace(/\D/g,'')) + moveBuff;
        movePlayer(moveValue);
        moveBuff = 0; // Consume the buff
      }
      if(cardName.includes('Focus')){
        let val = parseInt(cardName.replace(/\D/g,''));
        coins += val;
        logMsg(`Gained ${val} coins.`);
      }
      if(cardName.includes('Shadow Blocker')){
        isShadowBlocked = true;
        logMsg('Shadow Blocker is active! The next Cruxflare event will be blocked.');
      }
      if(cardName.includes('Dream Compass')){
        logMsg('The Dream Compass guides you... You draw a card.');
        drawHand(); // Draw a replacement card immediately
      }
      if(cardName.includes('Card Purge')){
        // This effect will now require the player to click a card in their hand to purge it.
        // For simplicity in this version, let's make it purge a dead card from discard.
        let deadCardIndex = discardPile.findIndex(c => (typeof c === 'string' && c.includes('Shadow')) || (c.name && c.name.includes('Shadow')));
        if (deadCardIndex !== -1) {
          let purged = discardPile.splice(deadCardIndex, 1);
          logMsg(`Purged a "${typeof purged[0] === 'string' ? purged[0] : purged[0].name}" from your discard pile.`);
        } else {
          logMsg("Card Purge found no 'Shadow' cards to remove from your discard pile.");
        }
      }

      discardPile.push(cardToDiscard);
      renderHand(); // Re-render hand after card was removed
      updateHUD();
    };
    h.appendChild(el);
  });
}

function renderMap(){
  let mapEl = document.getElementById('map');
  mapEl.innerHTML = '';
  for(let i = 0; i < mapNodes; i++){
    let node = document.createElement('div');
    node.className = 'node';
    if(fragmentPositions.includes(i)){ let f = document.createElement('div'); f.className = 'fragment'; node.appendChild(f); }
    let enc = encounterPositions.find(e => e.pos === i);
    if(enc){ let e = document.createElement('div'); e.className = `encounter ${enc.type}`; node.appendChild(e); }
    if(i === playerPos){ let p = document.createElement('div'); p.className = 'player'; node.appendChild(p); }
    mapEl.appendChild(node);
  }
}

function movePlayer(steps){
  playerPos = Math.min(playerPos + steps, mapNodes - 1);
  logMsg(`Moved ${steps} spaces.`);
  renderMap();

  if(fragmentPositions.includes(playerPos)){
    fragmentsCollected++;
    fragmentPositions = fragmentPositions.filter(pos => pos !== playerPos);
    logMsg(`Collected a fragment! Only ${totalFragments - fragmentsCollected} left!`);
    if(fragmentsCollected >= totalFragments){
      logMsg(`You collected all ${totalFragments} fragments! You win!`);
      endGame(true);
      return;
    }
  }

  let enc = encounterPositions.find(e => e.pos === playerPos);
  if(enc) triggerEncounter(enc.type);

  updateHUD();
  renderMap();
}

function triggerEncounter(type){
  if(type === 'treasure'){
    let gain = Math.ceil(Math.random() * 3) + 1; // 2 to 4 coins
    coins += gain;
    logMsg(`Encounter: Treasure! You found ${gain} coins.`);
  }
  if(type === 'heal'){
    let deadCardIndex = discardPile.findIndex(c => (typeof c === 'string' && c.includes('Shadow')) || (c.name && c.name.includes('Shadow')));
    if (deadCardIndex !== -1) {
      discardPile.splice(deadCardIndex, 1);
      logMsg('Encounter: Healing light! A "Shadow" card was removed from your discard pile.');
    } else {
      logMsg("Encounter: Healing light! (But you had no 'Shadow' cards to remove).");
    }
  }
  if(type === 'buff'){
    moveBuff += 2; // Add buff for the next move
    logMsg(`Encounter: Momentum surge! Your next Move card this turn gets +2 power.`);
  }
  updateHUD();
}

function updateHUD(){
  document.getElementById('coins').textContent = coins;
  document.getElementById('frags').textContent = `${fragmentsCollected}/${totalFragments}`;
  document.getElementById('turns-left').textContent = cruxflareDeck.length;
}

function logMsg(msg){ document.getElementById('log').textContent = msg; }
function errorMsg(msg){
  let el = document.getElementById('error-log');
  el.textContent = msg;
  setTimeout(() => { if (el.textContent === msg) el.textContent = ''; }, 2500);
}

function endTurn(){
  // Clear any leftover buffs
  moveBuff = 0;

  if(isShadowBlocked){
    logMsg('Your Shadow Blocker prevents the Cruxflare event!');
    isShadowBlocked = false;
  } else if(cruxflareDeck.length > 0){
    let event = cruxflareDeck.shift();
    logMsg(`Cruxflare: ${event}`);
    resolveCruxflare(event);
  }

  if (cruxflareDeck.length <= 0 && fragmentsCollected < totalFragments) {
    logMsg(`The dream has fully collapsed! You collected ${fragmentsCollected} of ${totalFragments} fragments.`);
    endGame(false);
    return;
  }

  drawHand();
  renderHand();
  updateHUD();
}

function resolveCruxflare(event){
  if(event.includes('dead card')) discardPile.push({name:'Shadow (dead)'});
  if(event.includes('cheapest card') && marketRow.length > 0){
    marketRow.sort((a, b) => a.cost - b.cost); // Sort by cost to find cheapest
    marketRow.shift();
    if(marketDeck.length > 0) marketRow.push(marketDeck.shift());
    renderMarket();
  }
  if(event.includes('Lose a node') && mapNodes > 2){
    // SAFE COLLAPSE: Check if a fragment is on the last node and move it
    if(fragmentPositions.includes(mapNodes - 1)){
        fragmentPositions = fragmentPositions.map(pos => pos === mapNodes - 1 ? mapNodes - 2 : pos);
        logMsg("The collapsing dream pushes a fragment to safety!");
    }
    mapNodes--;
    if(playerPos >= mapNodes) playerPos = mapNodes - 1; // Move player if they were on the collapsed node
    renderMap();
  }
  if(event.includes('Discard a random') && playerHand.length > 0){
    let randIndex = Math.floor(Math.random() * playerHand.length);
    let discardedCard = playerHand.splice(randIndex, 1)[0];
    discardPile.push(discardedCard);
    renderHand();
  }
}

function endGame(isWin){
  if (isWin) {
    document.getElementById('log').style.color = 'lime';
  } else {
    document.getElementById('log').style.color = 'red';
  }
  document.getElementById('market').innerHTML = '<h2>Game Over</h2>';
  document.getElementById('player-hand').innerHTML = '';
  document.getElementById('end-turn-btn').style.display = 'none';
  document.getElementById('restart-btn').style.display = 'inline-block';
}

function restartGame(){
  document.getElementById('log').style.color = ''; // Reset color
  initGame();
}

// Initial game start
initGame();
</script>
</body>
</html>
```
